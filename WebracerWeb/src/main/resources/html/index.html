<!DOCTYPE html>
<html>
<head>
    <title>Webracer</title>
</head>
<body>

<script>
    var connection;

    function connect() {
        var url = "ws://" + window.location.host + "/ws/";
        connection = new WebSocket(url);
        connection.onerror = function (error) {
            console.log("webSocket error: " + error);
        };
        connection.onmessage = function (message) {
            console.log("webSocket message: " + message.data);
        };
    }

    function disconnect() {
        connection.close();
    }

    function sendMessage() {
        console.log("sending message: " + message);
        connection.send(message);
    }

    connect();

</script>


<script src='http://cdn.html5quintus.com/v0.2.0/quintus-all.js'></script>

<script>

    // some constants

    // path to data
    var PATH = "/"

    // tile type numbers
    var TILE_ASPHALT = 1;
    var TILE_GRASS = 2;
    var TILE_WALL = 3;
    var TILE_FINISH = 4;
    var TILE_STARTPOS = 5;
    var TILE_SECTOR1 = 6;
    var TILE_SECTOR2 = 7;

    // time per round in milliseconds
    var TIMEOUT = 1000;

    // speed in px / TIMEOUT
    var SPEED1 = 10;
    var SPEED2 = 30;

    // steering left/right
    var DEGREES = 30;

    // steering status values
    var STEERING_STRAIGHT = "straight";
    var STEERING_LEFT = "left";
    var STEERING_RIGHT = "right";

    // key status values
    var KEY_UP = "acc";
    var KEY_DOWN = "brake";
    var KEY_LEFT = "left";
    var KEY_RIGHT = "right";
    var KEY_NONE = "none";

    // tile size
    var TILESIZE = 9;

    // init Quintus
    var Q = Quintus()
            .include("Sprites, Scenes, Input, 2D, UI")
            .setup({maximize: true})
            .controls(true);

    // helper method for converting pixel / tile position
    Q.tilePos = function(col, row) {
        return { x: col * TILESIZE, y: row * TILESIZE };
    }

    // disable default collision handling of 2d component,
    // we handle it in our RaceControl component
    var dd = Q.components["2d"].prototype.collision = function(x, y){};

    // behaviour of players car
    Q.component("RaceControl", {

        added: function() {
            var p = this.entity.p;

            // speed
            p.stepDistance = 0;

            // time per round in seconds
            p.stepDelay = TIMEOUT / 1000;

            // helper for keeping track of time
            p.stepWait = 0;

            // reigister event handlers
            this.entity.on("hit", this,"collision");
            this.entity.on("step",this,"step");
        },

        collision: function(col) {

            var p = this.entity.p;
            var tileNum = col.tile;

            // handle grass
            if(tileNum == TILE_GRASS){
                if(Q.state.get("speed") == SPEED2){
                    Q.state.set({speed: SPEED1})
                    Q.state.set({onGrass: true})
                }
            }
            else {
                Q.state.set({onGrass: false})
            }

            // handle wall
            if(tileNum == TILE_WALL){
                p.broken = true;
                p.diffX = 0;
                p.diffY = 0;
            }

            // handle sector 1
            if(tileNum == TILE_SECTOR1){
                // TODO
            }
            // handle sector 2
            if(tileNum == TILE_SECTOR2){
                // TODO
            }
            // handle finish
            if(tileNum == TILE_FINISH){
                // TODO
            }
        },

        step: function(dt) {

            var p = this.entity.p;

            if(p.broken){
                return;
            }

            var moved = false;

            // keep track of time
            p.stepWait -= dt;

            // move
            if(p.stepping) {
                p.x += p.diffX * dt / p.stepDelay;
                p.y += p.diffY * dt / p.stepDelay;
            }

            // next round?
            if(p.stepWait > 0) { return; }

            // move to end position if not there yet
            if(p.stepping) {
                p.x = p.destX;
                p.y = p.destY;
            }

            // stop moving
            p.stepping = false;
            p.diffX = 0;
            p.diffY = 0;

        },

        nextRound: function() {

            // calculate next round

//            console.log("player step");

            var p = this.entity.p;

            if(p.broken){
                return;
            }

            // get last pressed key and reset
            var lastKey = Q.state.get("lastKey");
            Q.state.set({lastKey: KEY_NONE});

            // set new steering
            var steering = Q.state.get("steering");
            if(lastKey == KEY_LEFT) {
                if(steering == STEERING_RIGHT){
                    steering = STEERING_STRAIGHT;
                } else if(steering == STEERING_STRAIGHT){
                    steering = STEERING_LEFT;
                }
            } else if(lastKey == KEY_RIGHT) {
                if(steering == STEERING_LEFT){
                    steering = STEERING_STRAIGHT;
                } else if(steering == STEERING_STRAIGHT){
                    steering = STEERING_RIGHT;
                }
            }
            Q.state.set({steering: steering})

            // rotate car according to steering
            if(steering == STEERING_LEFT){
                p.angle -= DEGREES;
            } else if(steering == STEERING_RIGHT){
                p.angle += DEGREES;
            }

            // set new speed
            var speed = Q.state.get("speed");
            if(lastKey == KEY_UP) {
                if(speed == 0){
                    speed = SPEED1;
                } else if(speed == SPEED1){
                    // prevent speeds2 on grass
                    if(!Q.state.get("onGrass")){
                        speed = SPEED2;
                    }
                }
            } else if(lastKey == KEY_DOWN) {
                if(speed == SPEED2){
                    speed = SPEED1;
                } else if(speed == SPEED1){
                    speed = 0;
                }
            }
            Q.state.set({speed: speed})
            p.stepDistance = speed;

            // calculate x and y of movement
            p.diffX = (Math.sin(2 * Math.PI * p.angle / 360) * p.stepDistance);
            p.diffY = - (Math.cos(2 * Math.PI * p.angle / 360) * p.stepDistance);

            // prepare movement
            if(p.diffY || p.diffX ) {
                p.stepping = true;
                p.origX = p.x;
                p.origY = p.y;
                p.destX = p.x + p.diffX;
                p.destY = p.y + p.diffY;
                p.stepWait = p.stepDelay;
            }

        }

    });

    // the player
    Q.Sprite.extend("Player",{
        init: function(p) {
            this._super(p, {
                sheet: "car1",
                scale: 1.2, // make car a bit bigger
                angle: 90, // starting position: heading right
                broken: false, // track if car is broken = hit the wall
                gravityX: 0, // oh, no gravity please :)
                gravityY: 0
            });

            // add the 2d and our RaceControl component
            this.add("2d, RaceControl");

            // save the latest key press
            upPressed = function() {
                Q.state.set({lastKey: KEY_UP});
            };
            downPressed = function() {
                Q.state.set({lastKey: KEY_DOWN});
            };
            leftPressed = function() {
                Q.state.set({lastKey: KEY_LEFT});
            };
            rightPressed = function() {
                Q.state.set({lastKey: KEY_RIGHT});
            }

            Q.input.on("up", this, upPressed);
            Q.input.on("down", this, downPressed);
            Q.input.on("left", this, leftPressed);
            Q.input.on("right", this, rightPressed);

        }

    });

//    Q.Sprite.extend("Other1",{
//        init: function(p) {
//            this._super(p, { sheet: "car2"});
//            this.add('2d');
//        }
//    });

    // extend default TileLayer for custom collision handling
    Q.TileLayer.extend("RaceTileLayer", {
        collidableTile: function(tileNum) {
            // starting grid is uninteresting
            return tileNum > 0 && tileNum != 5;
        }
    });

    // the track
    Q.scene("track", function(stage) {
        stage.collisionLayer(
                new Q.RaceTileLayer({
                    dataAsset: PATH + "track/track.json",
                    sheet: "tiles",
                    tileW: 9,
                    tileH: 9
                }));

        // add our car
        stage.player = stage.insert(new Q.Player(Q.tilePos(50, 35)));

        // new function for round based gameplay, forward to player
        stage.nextRound = function(){
            this.player.RaceControl.nextRound();
        }

        stage.add("viewport");

    });

    Q.scene('info',function(stage) {
        box = stage.insert(new Q.UI.Container({
            x: 0, y: 0, fill: "rgba(0, 0, 0, 0.3)"
        }));
        infotext = box.insert(
                new Q.UI.Text({x: 200, y: 70, label: "                                            \n \n "})
        );
        box.fit(5);

        updateStatus = function() {
            infotext.p.label = "speed: " + Q.state.get("speed") +
                "\nsteering: " + Q.state.get("steering") +
                "\nnextCommand: " + Q.state.get("lastKey");
        }

        Q.state.on("change.speed", updateStatus);
        Q.state.on("change.steering", updateStatus);
        Q.state.on("change.lastKey", updateStatus);

    });

    // preload all needed data, init some things when done
    Q.load(PATH + "tiles.png, " +
            PATH + "track/track.json, " +
            PATH + "cars.png, " +
            PATH + "cars.json",

        function() {
            // no gravity please :)
            Q.gravityX = 0;
            Q.gravityY = 0;

            // initial state
            Q.state.set({steering: STEERING_STRAIGHT});
            Q.state.set({speed: 0});
            Q.state.set({onGrass: false});

            // the graphics of the track
            Q.sheet("tiles", PATH + "tiles.png", { tilew: 9, tileh: 9 });
            // the cars
            Q.compileSheets(PATH + "cars.png", PATH + "cars.json");

            // init stage with the track
            Q.stageScene("track", 0);

            // init stage with infos
            Q.stageScene("info", 1);

            // start timeout (for client only testing)
            window.setTimeout(nextRound, TIMEOUT);
        }
    );

    // handle round based gameplay
    this.nextRound = function() {
        Q.stage(0).nextRound();
        window.setTimeout(nextRound, TIMEOUT);
    }

</script>

</body>
</html>